#include <ros/ros.h>
#include <opencv2/opencv.hpp>
#include <image_transport/image_transport.h>
#include <cv_bridge/cv_bridge.h>
#include <sensor_msgs/image_encodings.h>
#include <iostream>
#include <geometry_msgs/Point32.h>
#include <vrep_plugin/Turn.h>
#include <vrep_plugin/Pool_table_state.h>
#include <vector>

#include "NeuralNetwork.h"

using namespace ros;
using namespace cv;


#define INPUT_VECTOR_SIZE 256*128

const double MIN_ERROR_LEARN = 0.01;

cv_bridge::CvImageConstPtr img;
bool img_received = false; 
vrep_plugin::Turn player_turn;
vrep_plugin::Pool_table_state table_state;

inline void imageReceiveCallback(const sensor_msgs::ImageConstPtr& msg)
{
	img = cv_bridge::toCvShare(msg, sensor_msgs::image_encodings::BGR8);
	img_received = true;
}
inline void poolTableStateCallback(const vrep_plugin::Pool_table_state& msg)
{
	//table_state = msg;
	ROS_INFO("White ball position: x=%f y=%f z=%f", msg.white_ball.x, msg.white_ball.y, msg.white_ball.z);
}
/*
bool isOnLine(Mat& img, Point start, Point end, int level)
{
	bool center_point = (img.at<uchar>((start+end)*0.5) == 0); 
	bool result = (level == 0)? center_point && (img.at<uchar>(end) == 0) : center_point;
	if (level == MAX_RECURSION) 
	{
		return result;
	}
	else
	{ 				
		return result && isOnLine(img, start, (start+end)*0.5, level+1) && isOnLine(img, (start+end)*0.5, end, level+1);
	}
}

Point findLine(Mat& img, Point start)
{
	for (int i=0; i < start.y; i++)
	{
		for (int j=0; j< img.cols; j++)
		{
			//std::cout <<"Point -> " << j << " " << i << "\n";
			if (isOnLine(img, start, Point(j,i), 0)) 
			{	
				//std::cout <<"\tFound Point -> " << j << " " << i << "\n";
				return Point(j,i);
			}
		}
	}
	return Point(-1,-1);
}
*/
int main(int argc, char** argv)
{
	init(argc, argv, "ann_player");
	NodeHandle node;	
	image_transport::ImageTransport img_transport(node);
	image_transport::Subscriber img_sub = img_transport.subscribe("camera_image", 1, imageReceiveCallback);
	ros::Subscriber table_state_sub = node.subscribe("pool_table_state", 1, poolTableStateCallback);
	Rate img_refresh(30);

	std::vector<int> neuronNumbers;
	neuronNumbers.push_back(600);
	//neuronNumbers.push_back(1900);
	//neuronNumbers.push_back(500);
	neuronNumbers.push_back(2); //Neurons in layers
	
	srand(time(NULL));
					//input vector size, number of layers, neurons in layers 
	NeuralNetwork nn(INPUT_VECTOR_SIZE, neuronNumbers.size(), neuronNumbers); 
	
	vector<trainingCase> training_data_vector;	
	trainingCase training_data;
	training_data.output = vector<double>(2,0.f); // the line is in the center
	vector<double> nn_output;
	
	ROS_INFO("Awaiting...");
	//
	//Test
	//
	ros::ServiceClient pool_table = node.serviceClient<vrep_plugin::Turn>("player_turn");
	vrep_plugin::Turn turn;
	turn.request.angle = 0.0f;
	turn.request.power = 1; //.request.
	if(pool_table.call(turn))
	{
		ROS_INFO("Player score: %d", turn.response.score);	
	}
	else
	{
		ROS_INFO("Error receiving service.");
	}
	

	while(ros::ok())
	{
		if (img_received)
		{
			vector<cv::Mat> splited;
			cv::split(img->image, splited);

			vector<double> input;
			ROS_INFO("size in channels: %dx%d", splited[0].size().width, splited[0].size().height);
			
			for (unsigned int c = 0; c < 3; c++)
			{
				splited[c] *= (1/255); //normalize
				for (unsigned int i = 0; i < splited[c].rows; i++)
				{
					unsigned char* rowptr = splited[c].ptr(i);
					input.insert(input.end(), rowptr, rowptr + splited[c].cols);
				}
			}
			ROS_INFO("Input vector size: %d", input.size());
			ROS_INFO("start.");
			nn_output = nn.calculate(input);
			ROS_INFO("output: %f, %f", nn_output[0], nn_output[1]);
			training_data.input = input;
			training_data.output[0] = 0.5f;
			
			training_data.output[1] = 0.1f;

			training_data_vector.clear();

			training_data_vector.push_back(training_data);

			nn.trainWRTAccuracyError(training_data_vector, MIN_ERROR_LEARN, 10);
			ROS_INFO("end.");
			
			std::cout << "asdas " << std::endl;
			/*
			split image into vectors, feed into NN
			Get output +/- Gauss based on NN scoreboard, create a service, get result from service
			if score >= 10 train NN 
			update NN score board
			
			
			cvtColor(img->image, threshold_img, CV_BGR2GRAY);
			threshold(threshold_img, threshold_img, 77, 255, THRESH_BINARY); 
				
			
			*/
			img_received = false;
			imshow("Image", img->image);
			waitKey(2);
		}
		spinOnce();
		img_refresh.sleep();
	}
	shutdown();
	
}



